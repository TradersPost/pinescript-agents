//@version=6
indicator("Dynamic Support & Resistance", "Dynamic S&R", overlay=true, max_lines_count=50, max_labels_count=20)

// === INPUTS ===
pivot_length = input.int(10, "Pivot Length", minval=5, maxval=50, group="Settings")
min_strength = input.int(2, "Minimum Strength", minval=1, maxval=5, group="Settings")
zone_width = input.float(0.1, "Zone Width %", minval=0.01, maxval=1.0, group="Settings")
lookback_bars = input.int(500, "Lookback Bars", minval=100, maxval=2000, group="Settings")
max_levels = input.int(10, "Maximum Levels", minval=5, maxval=20, group="Settings")

// Display
show_zones = input.bool(true, "Show Zones", group="Display")
show_lines = input.bool(true, "Show Lines", group="Display")
show_breaks = input.bool(true, "Show Breaks", group="Display")
extend_right = input.int(50, "Extend Right", minval=10, maxval=200, group="Display")

// Colors
support_color = input.color(color.new(color.green, 20), "Support Zone", group="Colors")
resistance_color = input.color(color.new(color.red, 20), "Resistance Zone", group="Colors")
support_line = input.color(color.green, "Support Line", group="Colors")
resistance_line = input.color(color.red, "Resistance Line", group="Colors")
break_color = input.color(color.orange, "Break Color", group="Colors")

// === TYPES ===
type SRLevel
    float price
    int first_touch_bar
    int last_touch_bar
    int touch_count
    string level_type  // "support" or "resistance"
    bool is_broken
    int strength
    array<int> touch_bars

// === VARIABLES ===
var array<SRLevel> sr_levels = array.new<SRLevel>()
var line[] level_lines = array.new<line>()
var box[] level_zones = array.new<box>()
var label[] break_labels = array.new<label>()

// === FUNCTIONS ===
// Get pivot points
get_pivot_high() => ta.pivothigh(high, pivot_length, pivot_length)
get_pivot_low() => ta.pivotlow(low, pivot_length, pivot_length)

// Check if price is near level
is_near_level(price, level_price, threshold_pct) =>
    threshold = level_price * (threshold_pct / 100)
    math.abs(price - level_price) <= threshold

// Find existing level near price
find_existing_level(price, level_type) =>
    level_index = -1
    for i = 0 to array.size(sr_levels) - 1
        level = array.get(sr_levels, i)
        if level.level_type == level_type and not level.is_broken and is_near_level(price, level.price, zone_width)
            level_index := i
            break
    level_index

// Add or update SR level
update_sr_level(price, level_type, bar_idx) =>
    existing_index = find_existing_level(price, level_type)
    
    if existing_index >= 0
        // Update existing level
        existing_level = array.get(sr_levels, existing_index)
        existing_level.touch_count += 1
        existing_level.last_touch_bar := bar_idx
        existing_level.strength := math.min(existing_level.strength + 1, 5)
        array.push(existing_level.touch_bars, bar_idx)
        
        // Update price to average of touches
        total_price = existing_level.price * (existing_level.touch_count - 1) + price
        existing_level.price := total_price / existing_level.touch_count
        
        array.set(sr_levels, existing_index, existing_level)
    else
        // Create new level
        new_touches = array.new<int>()
        array.push(new_touches, bar_idx)
        
        new_level = SRLevel.new(
            price, bar_idx, bar_idx, 1, level_type, false, 1, new_touches)
        array.push(sr_levels, new_level)

// Check for level breaks
check_level_breaks() =>
    broken_levels = array.new<SRLevel>()
    
    for i = 0 to array.size(sr_levels) - 1
        level = array.get(sr_levels, i)
        if not level.is_broken
            is_break = false
            
            if level.level_type == "support" and low < level.price
                is_break := true
            else if level.level_type == "resistance" and high > level.price
                is_break := true
            
            if is_break
                level.is_broken := true
                array.set(sr_levels, i, level)
                array.push(broken_levels, level)
    
    broken_levels

// Clean old levels
clean_old_levels() =>
    current_bar = bar_index
    i = 0
    while i < array.size(sr_levels)
        level = array.get(sr_levels, i)
        bars_since_touch = current_bar - level.last_touch_bar
        
        if bars_since_touch > lookback_bars or (level.is_broken and bars_since_touch > 50)
            array.remove(sr_levels, i)
        else
            i += 1
    
    // Limit total levels
    while array.size(sr_levels) > max_levels * 2
        // Remove weakest level
        min_strength = 10
        weakest_index = 0
        for j = 0 to array.size(sr_levels) - 1
            level = array.get(sr_levels, j)
            if level.strength < min_strength
                min_strength := level.strength
                weakest_index := j
        
        if array.size(sr_levels) > weakest_index
            array.remove(sr_levels, weakest_index)

// Calculate level strength based on multiple factors
calculate_level_strength(level) =>
    base_strength = level.touch_count
    
    // Bonus for recent activity
    bars_since_last = bar_index - level.last_touch_bar
    recency_bonus = bars_since_last < 50 ? 2 : bars_since_last < 200 ? 1 : 0
    
    // Bonus for volume at touches (simplified)
    volume_bonus = level.touch_count >= 3 ? 1 : 0
    
    math.min(base_strength + recency_bonus + volume_bonus, 5)

// Draw levels
draw_sr_levels() =>
    // Clear old drawings
    for i = 0 to array.size(level_lines) - 1
        line.delete(array.get(level_lines, i))
    array.clear(level_lines)
    
    for i = 0 to array.size(level_zones) - 1
        box.delete(array.get(level_zones, i))
    array.clear(level_zones)
    
    // Sort levels by strength
    sorted_levels = array.copy(sr_levels)
    
    // Simple bubble sort by strength
    for i = 0 to array.size(sorted_levels) - 1
        for j = 0 to array.size(sorted_levels) - 2
            level1 = array.get(sorted_levels, j)
            level2 = array.get(sorted_levels, j + 1)
            if level1.strength < level2.strength
                array.set(sorted_levels, j, level2)
                array.set(sorted_levels, j + 1, level1)
    
    // Draw top levels
    levels_drawn = 0
    for i = 0 to array.size(sorted_levels) - 1
        if levels_drawn >= max_levels
            break
        
        level = array.get(sorted_levels, i)
        if not level.is_broken and level.strength >= min_strength
            line_color = level.level_type == "support" ? support_line : resistance_line
            zone_color = level.level_type == "support" ? support_color : resistance_color
            
            line_start = level.last_touch_bar
            line_end = bar_index + extend_right
            
            // Draw line
            if show_lines
                level_line = line.new(line_start, level.price, line_end, level.price,
                                    color=line_color, width=2, style=line.style_solid)
                array.push(level_lines, level_line)
            
            // Draw zone
            if show_zones
                zone_height = level.price * (zone_width / 100)
                zone_top = level.price + zone_height / 2
                zone_bottom = level.price - zone_height / 2
                
                level_zone = box.new(line_start, zone_top, line_end, zone_bottom,
                                   bgcolor=zone_color, border_color=line_color, border_width=1)
                array.push(level_zones, level_zone)
            
            levels_drawn += 1

// === MAIN LOGIC ===
if barstate.isconfirmed
    // Detect new pivot points
    pivot_high = get_pivot_high()
    pivot_low = get_pivot_low()
    
    // Add resistance levels from pivot highs
    if not na(pivot_high)
        update_sr_level(pivot_high, "resistance", bar_index - pivot_length)
    
    // Add support levels from pivot lows
    if not na(pivot_low)
        update_sr_level(pivot_low, "support", bar_index - pivot_length)
    
    // Check for breaks
    broken_levels = check_level_breaks()
    
    // Show break signals
    if show_breaks and array.size(broken_levels) > 0
        for i = 0 to array.size(broken_levels) - 1
            broken_level = array.get(broken_levels, i)
            label_text = broken_level.level_type == "support" ? "S-Break" : "R-Break"
            label_y = broken_level.level_type == "support" ? low : high
            
            break_label = label.new(bar_index, label_y, text=label_text,
                                   color=break_color, textcolor=color.white,
                                   size=size.small, style=label.style_label_down)
            array.push(break_labels, break_label)
            
            // Clean old break labels
            if array.size(break_labels) > 10
                old_label = array.shift(break_labels)
                label.delete(old_label)
    
    // Update level strengths
    for i = 0 to array.size(sr_levels) - 1
        level = array.get(sr_levels, i)
        level.strength := calculate_level_strength(level)
        array.set(sr_levels, i, level)
    
    // Clean old levels
    clean_old_levels()
    
    // Draw levels
    draw_sr_levels()

// === PLOTTING ===
// Plot pivot points for reference
plotshape(get_pivot_high(), style=shape.triangledown, location=location.abovebar,
          color=color.new(color.red, 50), size=size.tiny, title="Pivot High")
plotshape(get_pivot_low(), style=shape.triangleup, location=location.belowbar,
          color=color.new(color.green, 50), size=size.tiny, title="Pivot Low")

// === TABLE ===
if barstate.islast
    var table sr_table = table.new(position.top_left, 3, 6, bgcolor=color.white, border_width=1)
    
    table.cell(sr_table, 0, 0, "S&R Levels", text_color=color.black, text_size=size.small)
    table.cell(sr_table, 1, 0, "Count", text_color=color.black, text_size=size.small)
    table.cell(sr_table, 2, 0, "Strength", text_color=color.black, text_size=size.small)
    
    // Count support and resistance levels
    support_count = 0
    resistance_count = 0
    avg_support_strength = 0.0
    avg_resistance_strength = 0.0
    
    for i = 0 to array.size(sr_levels) - 1
        level = array.get(sr_levels, i)
        if not level.is_broken and level.strength >= min_strength
            if level.level_type == "support"
                support_count += 1
                avg_support_strength += level.strength
            else
                resistance_count += 1
                avg_resistance_strength += level.strength
    
    avg_support_strength := support_count > 0 ? avg_support_strength / support_count : 0
    avg_resistance_strength := resistance_count > 0 ? avg_resistance_strength / resistance_count : 0
    
    table.cell(sr_table, 0, 1, "Support", text_color=color.green, text_size=size.small)
    table.cell(sr_table, 1, 1, str.tostring(support_count), text_color=color.black, text_size=size.small)
    table.cell(sr_table, 2, 1, str.tostring(avg_support_strength, "#.#"), text_color=color.green, text_size=size.small)
    
    table.cell(sr_table, 0, 2, "Resistance", text_color=color.red, text_size=size.small)
    table.cell(sr_table, 1, 2, str.tostring(resistance_count), text_color=color.black, text_size=size.small)
    table.cell(sr_table, 2, 2, str.tostring(avg_resistance_strength, "#.#"), text_color=color.red, text_size=size.small)

// === ALERTS ===
// Alert on strong level breaks
strong_break = false
for i = 0 to array.size(sr_levels) - 1
    level = array.get(sr_levels, i)
    if level.is_broken and level.strength >= 3 and bar_index - level.last_touch_bar <= 1
        strong_break := true

alertcondition(strong_break, "Strong Level Break", "A strong support or resistance level has been broken")