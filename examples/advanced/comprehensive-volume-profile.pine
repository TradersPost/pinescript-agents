//@version=6
indicator("Comprehensive Volume Profile", "CVP", overlay=true, max_boxes_count=1000, max_lines_count=200)

// === INPUTS ===
// Profile Settings
profile_type = input.string("Session", "Profile Type", 
                           options=["Session", "Weekly", "Monthly", "Custom Range"], group="Profile")
custom_bars = input.int(100, "Custom Range Bars", minval=20, maxval=500, group="Profile")
profile_levels = input.int(50, "Profile Levels", minval=20, maxval=100, group="Profile")
volume_type = input.string("Volume", "Volume Type", 
                          options=["Volume", "Tick Volume"], group="Profile")

// Display Settings
show_profile = input.bool(true, "Show Volume Profile", group="Display")
show_poc = input.bool(true, "Show POC", group="Display")
show_value_area = input.bool(true, "Show Value Area", group="Display")
show_vwap = input.bool(true, "Show VWAP", group="Display")
show_developing = input.bool(true, "Show Developing Profile", group="Display")
extend_right = input.int(50, "Extend Right", minval=10, maxval=200, group="Display")

// Value Area Settings
value_area_pct = input.float(70.0, "Value Area %", minval=50.0, maxval=95.0, group="Value Area")
va_calculation = input.string("POC", "VA Calculation", 
                             options=["POC", "VWAP", "Median"], group="Value Area")

// Multi-timeframe
enable_mtf = input.bool(false, "Enable Multi-Timeframe", group="Multi-Timeframe")
htf_timeframe = input.timeframe("4H", "Higher Timeframe", group="Multi-Timeframe")
show_htf_poc = input.bool(true, "Show HTF POC", group="Multi-Timeframe")

// Colors and Styling
profile_color_high = input.color(color.new(color.blue, 50), "High Volume", group="Colors")
profile_color_med = input.color(color.new(color.gray, 70), "Medium Volume", group="Colors")
profile_color_low = input.color(color.new(color.gray, 85), "Low Volume", group="Colors")
poc_color = input.color(color.yellow, "POC Color", group="Colors")
vah_color = input.color(color.blue, "VAH Color", group="Colors")
val_color = input.color(color.blue, "VAL Color", group="Colors")
vwap_color = input.color(color.orange, "VWAP Color", group="Colors")

// === TYPES ===
type VolumeLevel
    float price
    float volume
    int bar_count
    float percentage

type VolumeProfile
    array<VolumeLevel> levels
    float poc_price
    float poc_volume
    float vah_price
    float val_price
    float vwap_price
    float total_volume
    float session_high
    float session_low
    int session_start
    int session_end
    bool is_complete

type ProfileStats
    float volume_at_price_avg
    float volume_distribution_stdev
    float skewness
    float kurtosis
    int high_volume_nodes
    int low_volume_nodes

// === VARIABLES ===
var VolumeProfile current_profile = VolumeProfile.new()
var array<VolumeProfile> completed_profiles = array.new<VolumeProfile>()
var box[] profile_boxes = array.new<box>()
var line[] profile_lines = array.new<line>()
var array<ProfileStats> profile_statistics = array.new<ProfileStats>()

// Developing profile variables
var array<VolumeLevel> developing_levels = array.new<VolumeLevel>()
var float developing_vwap = 0.0
var float developing_total_vol = 0.0
var float developing_total_pv = 0.0

// === FUNCTIONS ===
// Check for new session based on profile type
is_new_session() =>
    switch profile_type
        "Session" => timeframe.change("1D") 
        "Weekly" => timeframe.change("1W")
        "Monthly" => timeframe.change("1M")
        "Custom Range" => bar_index % custom_bars == 0
        => false

// Initialize new profile
init_new_profile() =>
    current_profile.levels := array.new<VolumeLevel>()
    current_profile.session_high := high
    current_profile.session_low := low
    current_profile.session_start := bar_index
    current_profile.session_end := bar_index
    current_profile.total_volume := 0.0
    current_profile.is_complete := false
    
    // Initialize developing profile
    array.clear(developing_levels)
    developing_vwap := 0.0
    developing_total_vol := 0.0
    developing_total_pv := 0.0

// Update session bounds
update_session_bounds() =>
    current_profile.session_high := math.max(current_profile.session_high, high)
    current_profile.session_low := math.min(current_profile.session_low, low)
    current_profile.session_end := bar_index

// Get volume data
get_volume_data() =>
    switch volume_type
        "Volume" => volume
        "Tick Volume" => 1.0
        => volume

// Calculate price level for volume distribution
get_price_level(price, session_high, session_low, num_levels) =>
    if session_high == session_low
        session_low
    else
        level_height = (session_high - session_low) / num_levels
        level_index = math.floor((price - session_low) / level_height)
        level_index := math.max(0, math.min(num_levels - 1, level_index))
        session_low + (level_index * level_height) + (level_height / 2)

// Distribute volume across price levels
distribute_volume(bar_high, bar_low, bar_close, bar_volume) =>
    if array.size(current_profile.levels) == 0
        // Initialize levels
        level_height = (current_profile.session_high - current_profile.session_low) / profile_levels
        for i = 0 to profile_levels - 1
            level_price = current_profile.session_low + (i * level_height) + (level_height / 2)
            new_level = VolumeLevel.new(level_price, 0.0, 0, 0.0)
            array.push(current_profile.levels, new_level)
    
    // Distribute volume based on price action within the bar
    typical_price = hlc3
    volume_weight = bar_volume
    
    // Find the appropriate level for this bar's typical price
    target_level_price = get_price_level(typical_price, current_profile.session_high, 
                                        current_profile.session_low, profile_levels)
    
    // Add volume to the target level
    for i = 0 to array.size(current_profile.levels) - 1
        level = array.get(current_profile.levels, i)
        if math.abs(level.price - target_level_price) < (current_profile.session_high - current_profile.session_low) / profile_levels
            level.volume += volume_weight
            level.bar_count += 1
            array.set(current_profile.levels, i, level)
            break
    
    current_profile.total_volume += volume_weight

// Calculate VWAP for session
calculate_vwap() =>
    if current_profile.total_volume > 0
        total_pv = 0.0
        for i = 0 to array.size(current_profile.levels) - 1
            level = array.get(current_profile.levels, i)
            total_pv += level.price * level.volume
        current_profile.vwap_price := total_pv / current_profile.total_volume

// Calculate POC (Point of Control)
calculate_poc() =>
    max_volume = 0.0
    poc_price = 0.0
    
    for i = 0 to array.size(current_profile.levels) - 1
        level = array.get(current_profile.levels, i)
        if level.volume > max_volume
            max_volume := level.volume
            poc_price := level.price
    
    current_profile.poc_price := poc_price
    current_profile.poc_volume := max_volume

// Calculate Value Area
calculate_value_area() =>
    if array.size(current_profile.levels) == 0 or current_profile.total_volume == 0
        return
    
    // Calculate percentages for each level
    for i = 0 to array.size(current_profile.levels) - 1
        level = array.get(current_profile.levels, i)
        level.percentage := (level.volume / current_profile.total_volume) * 100
        array.set(current_profile.levels, i, level)
    
    target_volume = current_profile.total_volume * (value_area_pct / 100.0)
    
    // Start from POC or VWAP based on setting
    center_price = switch va_calculation
        "POC" => current_profile.poc_price
        "VWAP" => current_profile.vwap_price
        "Median" => (current_profile.session_high + current_profile.session_low) / 2
        => current_profile.poc_price
    
    // Find center level index
    center_index = 0
    min_distance = math.abs(array.get(current_profile.levels, 0).price - center_price)
    for i = 1 to array.size(current_profile.levels) - 1
        level = array.get(current_profile.levels, i)
        distance = math.abs(level.price - center_price)
        if distance < min_distance
            min_distance := distance
            center_index := i
    
    // Expand from center to reach target volume
    accumulated_volume = array.get(current_profile.levels, center_index).volume
    upper_index = center_index
    lower_index = center_index
    
    while accumulated_volume < target_volume and (upper_index < array.size(current_profile.levels) - 1 or lower_index > 0)
        upper_vol = 0.0
        lower_vol = 0.0
        
        if upper_index < array.size(current_profile.levels) - 1
            upper_vol := array.get(current_profile.levels, upper_index + 1).volume
        
        if lower_index > 0
            lower_vol := array.get(current_profile.levels, lower_index - 1).volume
        
        if upper_vol >= lower_vol and upper_index < array.size(current_profile.levels) - 1
            upper_index += 1
            accumulated_volume += upper_vol
        else if lower_index > 0
            lower_index -= 1
            accumulated_volume += lower_vol
        else
            break
    
    current_profile.vah_price := array.get(current_profile.levels, upper_index).price
    current_profile.val_price := array.get(current_profile.levels, lower_index).price

// Calculate profile statistics
calculate_statistics() =>
    if array.size(current_profile.levels) == 0
        return
    
    // Calculate average volume per level
    total_volume = 0.0
    active_levels = 0
    for i = 0 to array.size(current_profile.levels) - 1
        level = array.get(current_profile.levels, i)
        if level.volume > 0
            total_volume += level.volume
            active_levels += 1
    
    avg_volume = active_levels > 0 ? total_volume / active_levels : 0.0
    
    // Count high and low volume nodes
    high_volume_threshold = avg_volume * 1.5
    low_volume_threshold = avg_volume * 0.5
    high_vol_nodes = 0
    low_vol_nodes = 0
    
    for i = 0 to array.size(current_profile.levels) - 1
        level = array.get(current_profile.levels, i)
        if level.volume > high_volume_threshold
            high_vol_nodes += 1
        else if level.volume < low_volume_threshold and level.volume > 0
            low_vol_nodes += 1
    
    new_stats = ProfileStats.new(avg_volume, 0.0, 0.0, 0.0, high_vol_nodes, low_vol_nodes)
    array.push(profile_statistics, new_stats)

// Draw volume profile
draw_volume_profile() =>
    if not show_profile or array.size(current_profile.levels) == 0
        return
    
    // Clear old profile boxes
    for i = 0 to array.size(profile_boxes) - 1
        box.delete(array.get(profile_boxes, i))
    array.clear(profile_boxes)
    
    // Find max volume for scaling
    max_volume = 0.0
    for i = 0 to array.size(current_profile.levels) - 1
        level = array.get(current_profile.levels, i)
        max_volume := math.max(max_volume, level.volume)
    
    if max_volume == 0
        return
    
    // Draw profile bars
    max_bar_width = extend_right * 0.8
    level_height = (current_profile.session_high - current_profile.session_low) / profile_levels
    
    for i = 0 to array.size(current_profile.levels) - 1
        level = array.get(current_profile.levels, i)
        if level.volume > 0
            bar_width = (level.volume / max_volume) * max_bar_width
            
            // Color based on volume intensity
            volume_ratio = level.volume / max_volume
            box_color = volume_ratio > 0.7 ? profile_color_high : 
                       volume_ratio > 0.3 ? profile_color_med : profile_color_low
            
            profile_box = box.new(current_profile.session_end, level.price - level_height/2,
                                 current_profile.session_end + bar_width, level.price + level_height/2,
                                 bgcolor=box_color, border_color=color.gray, border_width=1)
            array.push(profile_boxes, profile_box)

// Draw profile lines
draw_profile_lines() =>
    // Clear old lines
    for i = 0 to array.size(profile_lines) - 1
        line.delete(array.get(profile_lines, i))
    array.clear(profile_lines)
    
    line_start = current_profile.session_start
    line_end = current_profile.session_end + extend_right
    
    // POC line
    if show_poc and current_profile.poc_price > 0
        poc_line = line.new(line_start, current_profile.poc_price, line_end, current_profile.poc_price,
                           color=poc_color, width=3, style=line.style_solid)
        array.push(profile_lines, poc_line)
    
    // Value Area lines
    if show_value_area
        if current_profile.vah_price > 0
            vah_line = line.new(line_start, current_profile.vah_price, line_end, current_profile.vah_price,
                               color=vah_color, width=2, style=line.style_dashed)
            array.push(profile_lines, vah_line)
        
        if current_profile.val_price > 0
            val_line = line.new(line_start, current_profile.val_price, line_end, current_profile.val_price,
                               color=val_color, width=2, style=line.style_dashed)
            array.push(profile_lines, val_line)
    
    // VWAP line  
    if show_vwap and current_profile.vwap_price > 0
        vwap_line = line.new(line_start, current_profile.vwap_price, line_end, current_profile.vwap_price,
                            color=vwap_color, width=2, style=line.style_dotted)
        array.push(profile_lines, vwap_line)

// Higher timeframe POC
[htf_poc, htf_vwap] = if enable_mtf
    request.security(syminfo.tickerid, htf_timeframe, [current_profile.poc_price, current_profile.vwap_price],
                    lookahead=barmerge.lookahead_off)
else
    [na, na]

// === MAIN LOGIC ===
// Initialize on first bar
if barstate.isfirst
    init_new_profile()

// Check for new session
if is_new_session() and barstate.isconfirmed
    // Complete current profile
    if array.size(current_profile.levels) > 0
        calculate_poc()
        calculate_vwap()
        calculate_value_area()
        calculate_statistics()
        current_profile.is_complete := true
        
        // Save completed profile
        array.push(completed_profiles, current_profile)
        if array.size(completed_profiles) > 10
            array.shift(completed_profiles)
        
        draw_volume_profile()
        draw_profile_lines()
    
    // Start new profile
    init_new_profile()

// Update current session
if barstate.isconfirmed
    update_session_bounds()
    vol_data = get_volume_data()
    distribute_volume(high, low, close, vol_data)
    
    // Calculate current metrics
    calculate_poc()
    calculate_vwap()
    calculate_value_area()

// Draw developing profile
if show_developing and barstate.islast
    draw_volume_profile()
    draw_profile_lines()

// === PLOTTING ===
// Plot current VWAP
plot(show_vwap ? current_profile.vwap_price : na, title="Current VWAP", 
     color=vwap_color, linewidth=2, style=plot.style_line)

// Plot HTF levels
plot(enable_mtf and show_htf_poc ? htf_poc : na, title="HTF POC",
     color=color.purple, linewidth=3, style=plot.style_line)

// Background for new session
bgcolor(is_new_session() ? color.new(color.blue, 95) : na, title="New Session")

// === TABLE ===
if barstate.islast and show_profile
    var table profile_table = table.new(position.top_left, 2, 7, bgcolor=color.white, border_width=1)
    
    table.cell(profile_table, 0, 0, "Volume Profile", text_color=color.black, text_size=size.normal)
    table.cell(profile_table, 1, 0, "", text_color=color.black, text_size=size.normal)
    
    table.cell(profile_table, 0, 1, "POC", text_color=color.black, text_size=size.small)
    table.cell(profile_table, 1, 1, str.tostring(current_profile.poc_price, "#.####"), 
               text_color=poc_color, text_size=size.small)
    
    table.cell(profile_table, 0, 2, "VAH", text_color=color.black, text_size=size.small)
    table.cell(profile_table, 1, 2, str.tostring(current_profile.vah_price, "#.####"), 
               text_color=vah_color, text_size=size.small)
    
    table.cell(profile_table, 0, 3, "VAL", text_color=color.black, text_size=size.small)
    table.cell(profile_table, 1, 3, str.tostring(current_profile.val_price, "#.####"), 
               text_color=val_color, text_size=size.small)
    
    table.cell(profile_table, 0, 4, "VWAP", text_color=color.black, text_size=size.small)
    table.cell(profile_table, 1, 4, str.tostring(current_profile.vwap_price, "#.####"), 
               text_color=vwap_color, text_size=size.small)
    
    table.cell(profile_table, 0, 5, "Volume", text_color=color.black, text_size=size.small)
    table.cell(profile_table, 1, 5, str.tostring(current_profile.total_volume, "#"), 
               text_color=color.gray, text_size=size.small)
    
    // Current price relative to POC
    poc_distance = current_profile.poc_price > 0 ? ((close - current_profile.poc_price) / current_profile.poc_price) * 100 : 0
    table.cell(profile_table, 0, 6, "POC Dist", text_color=color.black, text_size=size.small)
    table.cell(profile_table, 1, 6, str.tostring(poc_distance, "#.##") + "%", 
               text_color=poc_distance > 0 ? color.green : color.red, text_size=size.small)